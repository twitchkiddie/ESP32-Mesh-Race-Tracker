<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Race Tracker — Live View</title>

  <!-- Leaflet (OSM fallback, no key required) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* ------------------------------------------------------------------ */
    /* Reset & base                                                         */
    /* ------------------------------------------------------------------ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:        #0d1117;
      --surface:   #161b22;
      --border:    #30363d;
      --text:      #e6edf3;
      --text-dim:  #8b949e;
      --accent:    #238636;
      --warn:      #d29922;
      --err:       #da3633;
      --panel-w:   320px;
      --hdr-h:     52px;
      --banner-h:  0px;  /* updated by JS when stale banner shown */
    }

    html, body { height: 100%; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); }

    /* ------------------------------------------------------------------ */
    /* Stale banner (hidden by default)                                    */
    /* ------------------------------------------------------------------ */
    #stale-banner {
      display: none;
      position: fixed; top: var(--hdr-h); left: 0; right: 0; z-index: 1200;
      background: #7a5c00; border-bottom: 1px solid #a07800;
      color: #ffd966; text-align: center;
      padding: 6px 16px; font-size: 13px; font-weight: 500;
    }
    #stale-banner.visible { display: block; }

    /* ------------------------------------------------------------------ */
    /* Header                                                               */
    /* ------------------------------------------------------------------ */
    header {
      position: fixed; top: 0; left: 0; right: 0; z-index: 1100;
      height: var(--hdr-h);
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex; align-items: center; gap: 12px; padding: 0 16px;
    }

    header h1 { font-size: 18px; font-weight: 600; white-space: nowrap; }
    header h1 span { color: var(--text-dim); font-weight: 400; font-size: 14px; margin-left: 6px; }

    .cloud-badge {
      display: flex; align-items: center; gap: 6px;
      padding: 4px 10px; border-radius: 20px;
      background: var(--bg); border: 1px solid var(--border);
      font-size: 13px; white-space: nowrap;
    }
    .cloud-badge .dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--err); transition: background 0.3s;
    }
    .cloud-badge.live  .dot { background: var(--accent); }
    .cloud-badge.stale .dot { background: var(--warn); }

    .hdr-stats {
      display: flex; gap: 16px; margin-left: auto;
      font-size: 13px; color: var(--text-dim);
    }
    .hdr-stats b { color: var(--text); }

    /* ------------------------------------------------------------------ */
    /* Map (offset accounts for optional stale banner)                     */
    /* ------------------------------------------------------------------ */
    #map-wrap {
      position: fixed;
      top: calc(var(--hdr-h) + var(--banner-h));
      left: 0; right: var(--panel-w); bottom: 0;
      background: #1c2128;
    }
    #map { width: 100%; height: 100%; }

    /* ------------------------------------------------------------------ */
    /* Side panel                                                           */
    /* ------------------------------------------------------------------ */
    #panel {
      position: fixed;
      top: calc(var(--hdr-h) + var(--banner-h));
      right: 0; width: var(--panel-w); bottom: 0;
      background: var(--surface);
      border-left: 1px solid var(--border);
      display: flex; flex-direction: column;
      overflow: hidden;
      transition: top 0.2s;
    }

    #panel-header {
      padding: 12px 14px 8px;
      border-bottom: 1px solid var(--border);
      font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em;
      color: var(--text-dim); flex-shrink: 0;
      display: flex; justify-content: space-between; align-items: center;
    }

    #node-list { overflow-y: auto; flex: 1; }

    /* Node card */
    .node-card {
      border-bottom: 1px solid var(--border);
      padding: 12px 14px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .node-card:hover { background: rgba(255,255,255,0.04); }
    .node-card.stale { opacity: 0.5; }

    .node-header {
      display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
    }
    .node-dot {
      width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0;
      box-shadow: 0 0 6px currentColor;
    }
    .node-name { font-weight: 600; font-size: 14px; }
    .node-age  { margin-left: auto; font-size: 11px; color: var(--text-dim); }

    .node-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px 12px;
      font-size: 12px;
    }
    .node-grid .label { color: var(--text-dim); }
    .node-grid .val   { color: var(--text); font-variant-numeric: tabular-nums; }
    .node-grid .full  { grid-column: 1 / -1; }

    .fix-good { color: #3fb950; }
    .fix-none { color: var(--err); }
    .fix-stale{ color: var(--warn); }

    /* Battery bar */
    .batt-bar {
      height: 4px; border-radius: 2px; background: var(--border); margin-top: 6px;
      overflow: hidden;
    }
    .batt-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }

    /* ------------------------------------------------------------------ */
    /* Map type buttons                                                     */
    /* ------------------------------------------------------------------ */
    #map-type-btns {
      position: absolute; bottom: 16px; left: 16px; z-index: 500;
      display: flex; gap: 6px;
    }
    .map-btn {
      background: var(--surface); border: 1px solid var(--border);
      color: var(--text); padding: 6px 12px; border-radius: 6px;
      font-size: 12px; cursor: pointer; transition: background 0.15s;
    }
    .map-btn:hover, .map-btn.active { background: #238636; border-color: #2ea043; }

    /* ------------------------------------------------------------------ */
    /* No-nodes placeholder                                                 */
    /* ------------------------------------------------------------------ */
    #no-nodes {
      padding: 32px 16px; text-align: center; color: var(--text-dim);
      font-size: 13px; line-height: 1.6;
    }

    /* ------------------------------------------------------------------ */
    /* Google Maps container                                               */
    /* ------------------------------------------------------------------ */
    #gmap { width: 100%; height: 100%; display: none; }

    /* ------------------------------------------------------------------ */
    /* Mobile responsive                                                    */
    /* ------------------------------------------------------------------ */
    @media (max-width: 768px) {
      :root { --panel-w: 0px; }
      #map-wrap { right: 0; }
      #panel {
        position: fixed; bottom: 0; left: 0; right: 0;
        top: auto; width: 100%; height: 40vh;
        border-left: none; border-top: 1px solid var(--border);
      }
    }
  </style>
</head>
<body>

<!-- Stale feed banner -->
<div id="stale-banner">⚠ Feed offline — last data <span id="stale-age">—</span> ago</div>

<!-- ===================================================================== -->
<!-- Header                                                                 -->
<!-- ===================================================================== -->
<header>
  <h1>Race Tracker <span id="hdr-subtitle">Live View ☁</span></h1>

  <div class="cloud-badge" id="cloud-badge">
    <div class="dot"></div>
    <span id="cloud-label">Connecting…</span>
  </div>

  <div class="hdr-stats">
    <div>Nodes: <b id="stat-nodes">0</b></div>
    <div>Feed: <b id="stat-age">—</b></div>
  </div>
</header>

<!-- ===================================================================== -->
<!-- Map                                                                    -->
<!-- ===================================================================== -->
<div id="map-wrap">
  <div id="map">
    <div id="gmap"></div>
    <div id="map-type-btns">
      <button class="map-btn active" onclick="setMapType('satellite')">Satellite</button>
      <button class="map-btn" onclick="setMapType('street')">Street</button>
      <button class="map-btn" onclick="setMapType('topo')">Topo</button>
    </div>
  </div>
</div>

<!-- ===================================================================== -->
<!-- Side Panel                                                             -->
<!-- ===================================================================== -->
<div id="panel">
  <div id="panel-header">
    <div style="display:flex;flex-direction:column;gap:2px">
      <span id="panel-title">Live Boats</span>
      <span id="panel-event-subtitle" style="font-size:11px;color:var(--text-dim);font-style:italic;display:none"></span>
    </div>
    <span id="panel-count" style="font-size:13px;color:var(--text)">0</span>
  </div>
  <div id="node-list">
    <div id="no-nodes">
      Waiting for boat data…<br><br>
      No tracker boats are currently visible.<br>Make sure the race trackers are powered on.
    </div>
  </div>
</div>

<!-- ===================================================================== -->
<!-- Script                                                                 -->
<!-- ===================================================================== -->
<script>
// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------
const GMAPS_KEY = '{{ gmaps_key }}';

// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
const HEAT_TYPE_LABELS = {
  heat: 'Heat', semi_final: 'Semi-Final', final: 'Final',
  time_trial: 'Time Trial', repechage: 'Repechage', exhibition: 'Exhibition'
};

let nodes      = {};
let cloudStale = true;
let cloudAgeS  = null;
let raceState  = null;   // data.race from relay (standings + course)

let mapMarkers  = {};   // mac → leaflet marker
let mapTrails   = {};   // mac → leaflet polyline
let gmapsMarkers = {};
let gmapsTrails  = {};
let useGmaps = false;
let leafletMap, googleMap;
let currentLeafletLayer = null;
let courseLayer = null;  // {startLine, finishLine, startMark, finishMark, courseName}

// When cloud feed is stale, dim map markers to this opacity
const STALE_OPACITY = 0.35;

// ---------------------------------------------------------------------------
// Leaflet tile layers
// ---------------------------------------------------------------------------
const TILE_LAYERS = {
  satellite: {
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attr: 'Esri World Imagery',
  },
  street: {
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attr: '© OpenStreetMap contributors',
  },
  topo: {
    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    attr: '© OpenTopoMap contributors',
  },
};

function initLeaflet() {
  leafletMap = L.map('map', { center: [43.104, -77.413], zoom: 16, zoomControl: true });
  currentLeafletLayer = L.tileLayer(TILE_LAYERS.satellite.url, {
    attribution: TILE_LAYERS.satellite.attr, maxZoom: 20,
  }).addTo(leafletMap);
}

function setMapType(type) {
  document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
  if (!useGmaps && leafletMap) {
    if (currentLeafletLayer) leafletMap.removeLayer(currentLeafletLayer);
    const cfg = TILE_LAYERS[type] || TILE_LAYERS.street;
    currentLeafletLayer = L.tileLayer(cfg.url, { attribution: cfg.attr, maxZoom: 20 }).addTo(leafletMap);
  }
  if (useGmaps && googleMap) {
    googleMap.setMapTypeId(type === 'satellite' ? 'satellite' : 'roadmap');
  }
}

// ---------------------------------------------------------------------------
// Google Maps
// ---------------------------------------------------------------------------
function initGoogleMaps() {
  document.getElementById('gmap').style.display = 'block';
  document.getElementById('map').querySelectorAll('.leaflet-container')
    .forEach(el => el.style.display = 'none');
  googleMap = new google.maps.Map(document.getElementById('gmap'), {
    center: { lat: 43.104, lng: -77.413 }, zoom: 16,
    mapTypeId: 'satellite', mapTypeControl: false,
    streetViewControl: false, fullscreenControl: false, zoomControl: true,
  });
  useGmaps = true;
}
window.initGoogleMaps = initGoogleMaps;

// ---------------------------------------------------------------------------
// Marker / trail rendering
// ---------------------------------------------------------------------------
function markerOpacity() { return cloudStale ? STALE_OPACITY : 1.0; }

function colorToLeafletIcon(color, label, headingDeg) {
  // Arrow points north (up) at 0°, rotates clockwise with heading.
  // Number badge counter-rotates so it always reads upright.
  const rot = headingDeg != null ? headingDeg : 0;
  const svg = `
    <svg xmlns='http://www.w3.org/2000/svg' width='44' height='44' viewBox='0 0 44 44'>
      <filter id='sh'><feDropShadow dx='0' dy='1' stdDeviation='1.5' flood-opacity='0.45'/></filter>
      <g transform='rotate(${rot},22,22)' filter='url(#sh)'>
        <polygon points='22,4 33,38 22,29 11,38'
                 fill='${color}' stroke='white' stroke-width='2'/>
      </g>
      <circle cx='22' cy='22' r='10' fill='rgba(0,0,0,0.55)' stroke='white' stroke-width='1.5'/>
      <text x='22' y='26' text-anchor='middle' fill='white' font-size='11'
            font-weight='bold' font-family='sans-serif'>${label}</text>
    </svg>`;
  return L.divIcon({ html: svg, iconSize: [44,44], iconAnchor: [22,22], popupAnchor: [0,-22], className: '' });
}

function updateLeafletMarker(node) {
  if (!leafletMap || !node.has_gps) return;
  const mac = node.mac;
  const latlng = [node.lat, node.lon];
  const icon   = colorToLeafletIcon(node.color, String(node.device_id), node.heading_deg);
  const popup  = buildPopupHtml(node);
  const op     = markerOpacity();

  if (mapMarkers[mac]) {
    mapMarkers[mac].setLatLng(latlng).setIcon(icon).setPopupContent(popup);
    mapMarkers[mac].setOpacity(op);
  } else {
    mapMarkers[mac] = L.marker(latlng, { icon, opacity: op })
      .bindPopup(popup, { maxWidth: 260 }).addTo(leafletMap);
  }

  const trail = node.trail.map(p => [p.lat, p.lon]);
  if (mapTrails[mac]) {
    mapTrails[mac].setLatLngs(trail).setStyle({ opacity: op * 0.7 });
  } else {
    mapTrails[mac] = L.polyline(trail, { color: node.color, weight: 3, opacity: op * 0.7 })
      .addTo(leafletMap);
  }
}

function updateGoogleMarker(node) {
  if (!googleMap || !node.has_gps) return;
  const mac = node.mac;
  const pos = { lat: node.lat, lng: node.lon };
  if (gmapsMarkers[mac]) {
    gmapsMarkers[mac].setPosition(pos);
  } else {
    gmapsMarkers[mac] = new google.maps.Marker({
      position: pos, map: googleMap,
      label: { text: String(node.device_id), color: 'white', fontWeight: 'bold', fontSize: '12px' },
      icon: { path: google.maps.SymbolPath.CIRCLE, scale: 14, fillColor: node.color,
               fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 },
    });
    const iw = new google.maps.InfoWindow({ content: buildPopupHtml(node) });
    gmapsMarkers[mac].addListener('click', () => iw.open(googleMap, gmapsMarkers[mac]));
  }

  const path = node.trail.map(p => ({ lat: p.lat, lng: p.lon }));
  if (gmapsTrails[mac]) {
    gmapsTrails[mac].setPath(path);
  } else {
    gmapsTrails[mac] = new google.maps.Polyline({
      path, strokeColor: node.color, strokeOpacity: 0.8, strokeWeight: 3, map: googleMap,
    });
  }
}

// Refresh marker opacity for all existing markers when stale flag changes
function refreshMarkerOpacity() {
  const op = markerOpacity();
  Object.values(mapMarkers).forEach(m => m.setOpacity(op));
  Object.values(mapTrails).forEach(t => t.setStyle({ opacity: op * 0.7 }));
}

// ---------------------------------------------------------------------------
// Course overlay — start line (green) + finish line (red)
// ---------------------------------------------------------------------------

function makeLineMarker(label, color) {
  const svg = `
    <svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'>
      <circle cx='14' cy='14' r='12' fill='${color}' stroke='white' stroke-width='2'/>
      <text x='14' y='18' text-anchor='middle' fill='white' font-size='11'
            font-weight='bold' font-family='sans-serif'>${label}</text>
    </svg>`;
  return L.divIcon({ html: svg, iconSize: [28,28], iconAnchor: [14,14], className: '' });
}

function drawCourse(course) {
  // Clear existing course layers
  if (courseLayer) {
    ['startLine','finishLine','startMark','finishMark'].forEach(k => {
      if (courseLayer[k]) courseLayer[k].remove();
    });
    courseLayer = null;
  }
  if (!course || !leafletMap) return;

  const sl = course.start_line, fl = course.finish_line;
  if (!sl || !fl) return;

  const startLine  = L.polyline([[sl.p1.lat, sl.p1.lon],[sl.p2.lat, sl.p2.lon]],
    { color: '#00cc44', weight: 3, opacity: 0.85 }).addTo(leafletMap);
  const finishLine = L.polyline([[fl.p1.lat, fl.p1.lon],[fl.p2.lat, fl.p2.lon]],
    { color: '#ff3333', weight: 3, opacity: 0.85 }).addTo(leafletMap);

  const sMid = [(sl.p1.lat + sl.p2.lat) / 2, (sl.p1.lon + sl.p2.lon) / 2];
  const fMid = [(fl.p1.lat + fl.p2.lat) / 2, (fl.p1.lon + fl.p2.lon) / 2];

  const startMark  = L.marker(sMid,  { icon: makeLineMarker('S', '#00cc44') }).addTo(leafletMap);
  const finishMark = L.marker(fMid,  { icon: makeLineMarker('F', '#ff3333') }).addTo(leafletMap);

  courseLayer = { startLine, finishLine, startMark, finishMark, courseName: course.name };
}

function syncCourse() {
  const course = raceState && raceState.course ? raceState.course : null;
  const newName = course ? course.name : null;
  const oldName = courseLayer ? courseLayer.courseName : null;
  if (newName !== oldName) drawCourse(course);
}

function buildPopupHtml(node) {
  const fix = node.has_gps ? `${node.lat.toFixed(5)}, ${node.lon.toFixed(5)}` : 'No fix';
  const hdg = node.heading_deg != null ? `${node.heading_deg.toFixed(0)}° ${compassDir(node.heading_deg)}` : '—';
  return `
    <div style="font-family:sans-serif;font-size:13px;min-width:200px">
      <div style="font-weight:bold;font-size:15px;color:${node.color};margin-bottom:6px">
        ● ${node.display_name || node.label}
      </div>
      <table style="border-collapse:collapse;width:100%">
        <tr><td style="color:#666;padding:2px 6px 2px 0">Speed</td><td>${fmtSpeed(node)}</td></tr>
        <tr><td style="color:#666;padding:2px 6px 2px 0">Heading</td><td>${hdg}</td></tr>
        <tr><td style="color:#666;padding:2px 6px 2px 0">Position</td><td>${fix}</td></tr>
        <tr><td style="color:#666;padding:2px 6px 2px 0">Updated</td><td>${fmtAge(node.age_s)}</td></tr>
      </table>
    </div>`;
}

// ---------------------------------------------------------------------------
// Auto-center on first GPS fix
// ---------------------------------------------------------------------------
let hasCentered = false;
function maybeCenterMap(node) {
  if (hasCentered || !node.has_gps) return;
  hasCentered = true;
  if (useGmaps && googleMap) googleMap.setCenter({ lat: node.lat, lng: node.lon });
  else if (leafletMap)        leafletMap.setView([node.lat, node.lon], 16);
}

// ---------------------------------------------------------------------------
// Panel rendering
// ---------------------------------------------------------------------------
function battLabel(node) {
  return node.batt_pct === -1 ? 'USB' : `${node.batt_pct}%`;
}
function battColor(pct) {
  if (pct === -1)  return '#58a6ff';
  if (pct < 20)    return '#da3633';
  if (pct < 50)    return '#d29922';
  return '#3fb950';
}
function fmtUptime(s) {
  if (!s) return '—';
  const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sec = s % 60;
  if (h > 0) return `${h}h ${m}m`;
  if (m > 0) return `${m}m ${sec}s`;
  return `${sec}s`;
}
function fmtAge(age) {
  if (age < 2)  return 'now';
  if (age < 60) return `${Math.round(age)}s ago`;
  return `${Math.round(age/60)}m ago`;
}
function fmtSpeed(node) {
  const kmh   = node.speed_kmph || 0;
  const mph   = (kmh * 0.621371).toFixed(1);
  const knots = (kmh * 0.539957).toFixed(1);
  return `${kmh.toFixed ? kmh.toFixed(1) : kmh} km/h · ${mph} mph · ${knots} kn`;
}
function compassDir(deg) {
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE',
                'S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return dirs[Math.round((deg % 360) / 22.5) % 16];
}

function rankLabel(rank) {
  if (rank <= 0) return '';
  const sfx = rank === 1 ? 'st' : rank === 2 ? 'nd' : rank === 3 ? 'rd' : 'th';
  const col  = rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : rank === 3 ? '#CD7F32' : '#666';
  return `<span style="background:${col};color:#111;padding:1px 7px;border-radius:10px;
                font-size:11px;font-weight:bold;margin-right:4px">${rank}${sfx}</span>`;
}

function renderPanel() {
  const list       = document.getElementById('node-list');
  const noNodes    = document.getElementById('no-nodes');
  const titleEl    = document.getElementById('panel-title');
  const subtitleEl = document.getElementById('panel-event-subtitle');
  const raceBoats  = raceState && raceState.boats && raceState.boats.length > 0;
  const raceActive = raceState && (raceState.race_active || raceState.race_finished);

  // Panel title + event subtitle
  if (titleEl) titleEl.textContent = raceActive ? 'Race Standings' : 'Live Boats';
  if (subtitleEl) {
    const heatName = raceState && raceState.active_heat && raceState.active_heat.name;
    const heatType = raceState && raceState.active_heat && raceState.active_heat.type;
    let subtitle = '';
    if (heatName) {
      const typeLabel = HEAT_TYPE_LABELS[heatType] || heatType;
      subtitle = (heatType && heatType !== 'heat') ? `${heatName} (${typeLabel})` : heatName;
    }
    subtitleEl.textContent = subtitle;
    subtitleEl.style.display = subtitle ? '' : 'none';
  }

  // Build display list
  let displayList;
  if (raceBoats) {
    // Merge race boat data with live node data; skip boats not in nodes (no GPS yet)
    displayList = raceState.boats
      .filter(b => b.status !== 'dnf' && nodes[b.mac])
      .map(b => ({ ...nodes[b.mac], _race: b }))
      .sort((a, b) => {
        const ra = a._race.rank || 999, rb = b._race.rank || 999;
        return ra !== rb ? ra - rb : a.device_id - b.device_id;
      });
    // Append any tracker nodes not in race boats list
    Object.values(nodes).forEach(n => {
      if (!displayList.some(d => d.mac === n.mac)) displayList.push(n);
    });
  } else {
    displayList = Object.values(nodes).sort((a, b) =>
      a.device_id - b.device_id);
  }

  document.getElementById('panel-count').textContent = displayList.length;

  if (displayList.length === 0) {
    noNodes.style.display = '';
    list.querySelectorAll('.node-card').forEach(el => el.remove());
    return;
  }
  noNodes.style.display = 'none';

  displayList.forEach(node => {
    const id = `card-${node.mac.replace(/:/g, '')}`;
    let card = document.getElementById(id);
    if (!card) {
      card = document.createElement('div');
      card.id = id; card.className = 'node-card';
      card.onclick = () => panFocusNode(node.mac);
      list.appendChild(card);
    }
    card.className = `node-card${node.is_stale ? ' stale' : ''}`;

    const name = node.display_name || node.label;
    const hdg  = node.heading_deg != null
                   ? `${node.heading_deg.toFixed(0)}° ${compassDir(node.heading_deg)}`
                   : '—';
    const r    = node._race;

    card.innerHTML = `
      <div class="node-header">
        <div class="node-dot" style="background:${node.color};color:${node.color}"></div>
        <span class="node-name">${r ? rankLabel(r.rank) : ''}${name}</span>
        <span class="node-age">${fmtAge(node.age_s)}</span>
      </div>
      <div class="node-grid">
        ${node.has_gps ? `
        <span class="label full val">${fmtSpeed(node)}</span>
        <span class="label">Heading</span>
        <span class="val">${hdg}</span>
        ${r && r.gap_fmt ? `
        <span class="label">Gap</span>
        <span class="val" style="color:${r.rank===1?'#3fb950':'var(--text)'}">${r.gap_fmt}</span>` : ''}
        <span class="label full" style="color:var(--text-dim);font-size:11px">
          ${node.lat.toFixed(5)}, ${node.lon.toFixed(5)}
        </span>` : `
        <span class="label full fix-none" style="padding:4px 0">No GPS fix</span>`}
      </div>`;
  });

  // Remove cards for nodes that no longer exist in displayList
  list.querySelectorAll('.node-card').forEach(card => {
    const found = displayList.some(n => `card-${n.mac.replace(/:/g, '')}` === card.id);
    if (!found) card.remove();
  });
}

function panFocusNode(mac) {
  const node = nodes[mac];
  if (!node || !node.has_gps) return;
  if (useGmaps && googleMap) googleMap.panTo({ lat: node.lat, lng: node.lon });
  else if (leafletMap)        leafletMap.panTo([node.lat, node.lon]);
}

// ---------------------------------------------------------------------------
// Header / stale banner
// ---------------------------------------------------------------------------
function updateHeader(prevStale) {
  // Show active event + heat name in header subtitle
  const sub = document.getElementById('hdr-subtitle');
  if (sub) {
    let txt = 'Live View ☁';
    if (raceState && raceState.active_event && raceState.active_event.name) {
      txt = raceState.active_event.name;
      if (raceState.active_heat && raceState.active_heat.name)
        txt += ' · ' + raceState.active_heat.name;
    }
    sub.textContent = txt;
  }

  const badge = document.getElementById('cloud-badge');
  const label = document.getElementById('cloud-label');
  const banner = document.getElementById('stale-banner');
  const ageEl  = document.getElementById('stale-age');

  document.getElementById('stat-nodes').textContent = Object.keys(nodes).length;

  if (cloudAgeS === null) {
    badge.className = 'cloud-badge';
    label.textContent = 'No data yet';
    document.getElementById('stat-age').textContent = '—';
  } else if (cloudStale) {
    badge.className = 'cloud-badge stale';
    label.textContent = `Stale — ${cloudAgeS}s old`;
    document.getElementById('stat-age').textContent = `${cloudAgeS}s old`;
    ageEl.textContent = fmtAge(cloudAgeS);
    banner.classList.add('visible');
  } else {
    badge.className = 'cloud-badge live';
    label.textContent = `Live — ${cloudAgeS}s old`;
    document.getElementById('stat-age').textContent = `${cloudAgeS}s old`;
    banner.classList.remove('visible');
  }

  // Adjust map/panel top offset for banner
  const bannerH = cloudStale && cloudAgeS !== null ? banner.offsetHeight : 0;
  document.documentElement.style.setProperty('--banner-h', bannerH + 'px');

  // Refresh marker opacity if stale changed
  if (prevStale !== cloudStale) refreshMarkerOpacity();
}

// ---------------------------------------------------------------------------
// Polling — /api/state every 3 s
// ---------------------------------------------------------------------------
async function poll() {
  const prevStale = cloudStale;
  try {
    const resp = await fetch('/api/state');
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    const data = await resp.json();

    // Filter to tracker nodes only (role 0) — relays/gateways are infrastructure
    const allNodes = data.nodes || {};
    nodes = Object.fromEntries(Object.entries(allNodes).filter(([, n]) => n.role === 0));

    cloudAgeS  = data.cloud_age_s != null ? data.cloud_age_s : null;
    cloudStale = data.cloud_stale !== false;   // default true if missing
    raceState  = data.race || null;

    // When a heat is active, restrict visible nodes to that heat's MACs only.
    if (raceState && raceState.active_heat &&
        Array.isArray(raceState.active_heat.tracker_macs) &&
        raceState.active_heat.tracker_macs.length > 0) {
      const heatMacs = new Set(raceState.active_heat.tracker_macs);
      nodes = Object.fromEntries(Object.entries(nodes).filter(([mac]) => heatMacs.has(mac)));
    }

    // Sync start/finish course lines onto map
    syncCourse();

    // Remove map markers for any node no longer in the tracker set
    [...Object.keys(mapMarkers)].forEach(mac => {
      if (!nodes[mac]) {
        if (mapMarkers[mac]) { if (leafletMap) mapMarkers[mac].remove(); delete mapMarkers[mac]; }
        if (mapTrails[mac])  { if (leafletMap) mapTrails[mac].remove();  delete mapTrails[mac];  }
        if (gmapsMarkers[mac]) { gmapsMarkers[mac].setMap(null); delete gmapsMarkers[mac]; }
        if (gmapsTrails[mac])  { gmapsTrails[mac].setMap(null);  delete gmapsTrails[mac];  }
      }
    });

    Object.values(nodes).forEach(node => {
      maybeCenterMap(node);
      if (useGmaps) updateGoogleMarker(node);
      else          updateLeafletMarker(node);
    });

    renderPanel();
    updateHeader(prevStale);
  } catch (err) {
    console.warn('[Poll] Error:', err);
    cloudStale = true;
    updateHeader(prevStale);
  }
}

poll();
setInterval(poll, 3000);

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
  if (GMAPS_KEY && GMAPS_KEY !== 'None' && GMAPS_KEY.trim() !== '') {
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GMAPS_KEY}&callback=initGoogleMaps`;
    script.async = true; script.defer = true;
    document.head.appendChild(script);
    initLeaflet();   // fallback while Google Maps loads
  } else {
    initLeaflet();
  }
});
</script>

{% if gmaps_key %}<!-- Google Maps key present -->{% endif %}

</body>
</html>
